# Text cleaner

## Допущения

 Ввиду неполноты задания, придумываем недостающие условия:
- Исходим из того, что настройки обработчика (длина удаляемых слов, путь для обработанных файлов и т.п.) не меняются или меняются редко, храним их в конфиг-файле. Предполагаем, что пользователь достаточно продвинут чтобы вручную отредактировать JSON. Эти настройки легко могут быть вынесены в UI, но сделают UI громоздким и потребуют гораздо больше действий со стороны пользователя при добавлении файлов, поэтому выбран такой компромисс.
- Обрабатываемые файлы слишком велики чтобы быть загруженными целиком в память.
- Файлов много и возможность добавления их пакетами важна, а также важна необходимость долгоживущей очереди, устойчивой к сбоям приложения.
- Файлы находятся на жестких дисках и скорость процессинга лимитируется скоростью чтения и записи на диск, что делает распараллеливание бесполезным и даже вредным.
- Если целевой файл существует, он будет перезаписан. Такое поведение оправдано тем что для обработанных файлов используется специально выделенная папка.
- Считаем, что файлы имеют кодировку UTF8.
- Считаем что запущен только один экземпляр программы.
- Логгируем, но логи в файл не пишем.


## Реализация

##### - Бизнес логика реализована как class library и содержит
- Очередь задач. Одна задача = 1 обрабатываемый файл + параметры. Очередь персистентна (сохраняется при перезапуске приложения). Файл удаляется из очереди только если он полностью обработан или если произошла непредвиденная ошибка. Частично обработанные файлы обрабатываются заново после перезапуска.
- Процессор очереди, умеющий помещать файлы в очередь, извлекать их из нее и запускать обработку.
- Читалка файлов, обеспечивающая минимальное использование памяти - только буфер
- Обработчик текста, работающий с текстовым буфером читалки
- Утилита PunctuationProvider, возвращающая список знаков препинания
- TextCleanerServiceCollectionExtensions для регистрации всех сервисой пачкой в DI

Сервисы обернуты интерфейсами для юнит-тестирования.

##### - UI - WPF приложение:
-  Generic host для DI
-  CommunityToolkit.MVVM для MVVM
-  Имплементация ILogger для WPF
-  Конфиг с настройками (работает через IOptions и appsettings.json)
-  Одна вьюмодель, подписанная на ивенты бэкенд-сервисов
-  Собственно юай.

При необходимости UI может быть заменен на другой фреймворк, однако для этого нужно будет немного подчистить архитектуру, выделив обще-юайные сущности (напр. конфиг) в отдельный проект, а фреймворк-специфик-сущности (FileOpenDialog) наоборот, отделить от вьюмодели. Но этого нет в ТЗ, поэтому так.

##### - Вспомогательная программка для генерации рандомных текстовых файлов.

##### - Какие-то юнит-тесты. 



