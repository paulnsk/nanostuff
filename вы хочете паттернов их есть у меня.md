### Сводный список паттернов проектирования

#### Поведенческие паттерны (Behavioral)

1.  **Command (Команда)**
    *   **Цель:** Инкапсулировать запрос в виде объекта, позволяя передавать его, ставить в очередь и поддерживать отмену.
    *   **Реализация:**
        *   **ATM:** `RelayCommand` для связи кнопок UI с методами ViewModel (`WithdrawCommand`); передача лямбд `onDeposit`/`onCancel` в `WalletViewModel`.
        *   **TextCleaner:** `RelayCommand` для связи кнопки "Добавить файлы" с методом `AddFilesCommand` во `MainViewModel`.

2.  **Observer (Наблюдатель)**
    *   **Цель:** Создать механизм подписки, позволяющий объектам следить за событиями в других объектах.
    *   **Реализация:**
        *   **ATM:** ViewModel наследуются от `ObservableObject` (`INotifyPropertyChanged`), View подписывается на изменения свойств для обновления UI. `ObservableCollection` уведомляет об изменении состава коллекций.
        *   **TextCleaner:** Аналогично проекту ATM. Также, `FileProcessingService` использует стандартные C# события (`QueueChanged`, `Progress`) для уведомления подписчиков (`MainViewModel`) об изменениях.

3.  **Iterator (Итератор)**
    *   **Цель:** Предоставить способ последовательного доступа к элементам составного объекта, не раскрывая его внутреннего устройства.
    *   **Реализация:**
        *   **TextCleaner:** `BlockStreamReader` использует `yield return` в методе `ReadBlocks`, что позволяет клиенту (`FileProcessingService`) перебирать блоки файла в цикле `foreach`, не зная о внутренней логике буферизации.

4.  **Mediator (Посредник)**
    *   **Цель:** Инкапсулировать способ взаимодействия множества объектов, уменьшая их прямую связанность.
    *   **Реализация:**
        *   **TextCleaner:** `UiLogRelayService` выступает посредником между источниками логов (`WpfLogger`) и их получателем (`MainViewModel`). Компоненты не знают друг о друге, общаясь только через посредника.

5.  **Memento (Снимок)**
    *   **Цель:** Зафиксировать и сохранить внутреннее состояние объекта, чтобы его можно было позже восстановить.
    *   **Реализация:**
        *   **TextCleaner:** `PersistentQueueStorageService` сохраняет состояние очереди заданий в JSON-файл (`Save`) и восстанавливает его из файла (`Load`), реализуя внешнее хранение состояния.

#### Структурные паттерны (Structural)

1.  **Adapter (Адаптер)**
    *   **Цель:** Преобразовать интерфейс одного класса в интерфейс, ожидаемый клиентом.
    *   **Реализация:**
        *   **ATM:** `RelayCommand` адаптирует обычный метод ViewModel к интерфейсу `ICommand`, требуемому элементами управления WPF.

2.  **Facade (Фасад)**
    *   **Цель:** Предоставить единый, упрощенный интерфейс к сложной подсистеме.
    *   **Реализация:**
        *   **TextCleaner:** `FileProcessingService` скрывает сложную логику управления очередью, потоками и файловыми операциями за простым интерфейсом `IFileProcessingService`.

3.  **Flyweight (Приспособленец)**
    *   **Цель:** Эффективно использовать разделяемые объекты для представления большого количества однотипных мелких объектов.
    *   **Реализация:**
        *   **TextCleaner:** В классе `TextCleaner` статическое поле `WordRegex` компилируется один раз и переиспользуется для всех вызовов, экономя ресурсы на компиляции регулярного выражения.

#### Порождающие паттерны (Creational)

1.  **Singleton (Одиночка)**
    *   **Цель:** Гарантировать, что у класса есть только один экземпляр, и предоставить к нему глобальную точку доступа.
    *   **Реализация:**
        *   **ATM:** `ObjectToVisibilityConverter.Instance` (хотя в коде не используется).

2.  **Factory Method (Фабричный метод)**
    *   **Цель:** Определить интерфейс для создания объекта, но позволить подклассам решать, какой класс инстанцировать.
    *   **Реализация:**
        *   **TextCleaner:** `WpfLoggerProvider` реализует `ILoggerProvider` и его метод `CreateLogger` выступает как фабричный метод для создания экземпляров `WpfLogger`.

#### Архитектурные и специфичные для фреймворков паттерны

1.  **Model-View-ViewModel (MVVM)**
    *   **Цель:** Разделение логики представления, пользовательского интерфейса и данных.
    *   **Реализация:**
        *   **ATM & TextCleaner:** Оба проекта построены на этом паттерне, разделяя код на View (XAML), ViewModel и Model/Services.

2.  **Dependency Injection (Внедрение зависимости)**
    *   **Цель:** Реализация принципа инверсии управления (IoC), при которой зависимости объекта предоставляются извне.
    *   **Реализация:**
        *   **ATM & TextCleaner:** Оба проекта используют DI через конструктор. Например, `MainViewModel` получает `IFileProcessingService` в конструкторе.

3.  **Layered Architecture (Слоёная архитектура)**
    *   **Цель:** Разделение приложения на слои с четко определенными обязанностями.
    *   **Реализация:**
        *   **TextCleaner:** Проект имеет четкую структуру слоев: `WPF` (представление) и `BLL` (бизнес-логика).

4.  **Value Converter (Конвертер значений)**
    *   **Цель:** Специфичный для XAML-фреймворков паттерн для преобразования данных в процессе привязки.
    *   **Реализация:**
        *   **ATM:** `ObjectToVisibilityConverter` преобразует объект в значение `Visibility`.
